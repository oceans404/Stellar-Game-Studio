# Stellar Game Studio

Starter kit for building web3 games on Stellar that integrate with Game Hub.

## Quick Start

**Prerequisites:**
- [Bun](https://bun.sh/) v1.0+
- [Rust](https://www.rust-lang.org/) v1.84.0+ with `wasm32v1-none` target
- [Stellar CLI](https://developers.stellar.org/docs/tools/developer-tools) v21.0+

```bash
# Install dependencies
curl -fsSL https://bun.sh/install | bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
cargo install --locked stellar-cli --features opt
rustup target add wasm32v1-none

# Setup and run
bun run setup
```

Your dev server will start at http://localhost:3000

## Project Structure

```
├── contracts/               # Smart contracts for games and Game Hub mock
├── sgs_frontend/src/games/  # Studio game UI components (catalog)
├── <game>-frontend/         # Standalone game frontend (generated by create)
├── scripts/                 # Build & deployment automation
└── bindings/                # Generated TypeScript bindings
```

## Development Commands

```bash
bun run setup      # Full setup (build + deploy + configure + start)
bun run build      # Build contracts only
bun run deploy     # Deploy to testnet only
bun run bindings   # Generate TypeScript bindings only
bun run create my-game  # Scaffold contract + standalone frontend
bun run publish my-game # Export standalone frontend

# Contract testing
cd contracts/number-guess && cargo test

# Start studio frontend
bun run dev

# Build studio frontend to docs/ (for GitHub Pages)
cd sgs_frontend && bun run build:docs
```

## Documentation

The core game-development steps are below so you can follow them without running the UI.

## Develop a New Game

### Overview
Adding a new game means:
- Create a Soroban contract.
- Scaffold a standalone frontend for the game.
- Optionally register the game in the studio catalog.

The build/deploy/bindings/setup scripts auto-discover contracts from the workspace, so you do **not** need to edit scripts when adding a game.

### Step 1: Run the Create Command
```bash
bun run create my-game
```
If `my-game-frontend/` or `contracts/my-game/` already exist, use `--force` to overwrite.

### Step 2: Update the Contract Manifest
Edit `contracts/my-game/Cargo.toml`:
```toml
[package]
name = "my-game"
version = "0.1.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]
doctest = false

[dependencies]
soroban-sdk = { workspace = true }
```

### Step 3: Add the Contract to the Workspace
The create script updates the root `Cargo.toml` for you:
```toml
[workspace]
resolver = "2"
members = [
  "contracts/mock-game-hub",
  "contracts/twenty-one",
  "contracts/number-guess",
  "contracts/my-game", # Add this line
]
```

### Step 4: Implement Required Game Hub Calls
Your game contract should call `start_game` and `end_game` on the Game Hub contract.
```rust
#[contractclient(name = "GameHubClient")]
pub trait GameHub {
    fn start_game(
        env: Env,
        game_id: Address,
        session_id: u32,
        player1: Address,
        player2: Address,
        player1_points: i128,
        player2_points: i128,
    );

    fn end_game(
        env: Env,
        session_id: u32,
        player1_won: bool
    );
}
```

### Step 5: Test Your Contract
```bash
cd contracts/my-game
cargo test
```

#### Native Rust Tests (Mock GameHub)
Game contracts are expected to use a minimal in-memory Mock GameHub for unit tests.
This keeps tests fast and deterministic while preserving the real integration interface.

Examples:
- `contracts/number-guess/src/test.rs`
- `contracts/twenty-one/src/test.rs`

Key pattern:
```rust
let env = Env::default();
env.mock_all_auths();

// Deploy mock GameHub and game contract
let hub_addr = env.register(MockGameHub, ());
let admin = Address::generate(&env);
let game_id = env.register(MyGameContract, (&admin, &hub_addr));
let client = MyGameContractClient::new(&env, &game_id);

// Optional: whitelist game in mock
let game_hub = MockGameHubClient::new(&env, &hub_addr);
game_hub.add_game(&game_id);
```

Run:
```bash
cd contracts/my-game
cargo test
```

### Step 6: Build, Deploy, Generate Bindings (Automatic)
Once listed in the workspace, these scripts automatically build/deploy and generate bindings:
```bash
bun run setup
```

Example: a crate named `my-game` generates `bindings/my_game/` and writes
`VITE_MY_GAME_CONTRACT_ID` to the root `.env`.

### Step 7: Refine the Standalone Frontend
The create script scaffolds a standalone UI in:
```
my-game-frontend/src/games/my-game/
```

Update the service to accept a `contractId` (instead of hard-coding it):
```ts
// myGameService.ts
import { Client as MyGameClient } from 'my-game';
import { NETWORK_PASSPHRASE, RPC_URL } from '@/utils/constants';

export class MyGameService {
  private contractId: string;
  private baseClient: MyGameClient;

  constructor(contractId: string) {
    this.contractId = contractId;
    this.baseClient = new MyGameClient({
      contractId: this.contractId,
      networkPassphrase: NETWORK_PASSPHRASE,
      rpcUrl: RPC_URL,
    });
  }
}
```

In your component, wire it up with the contract ID helper:
```ts
import { getContractId } from '@/utils/constants';
import { MyGameService } from './myGameService';

const myGameService = new MyGameService(getContractId('my-game'));
```

### Step 8: Register the Game in the Studio Catalog (Optional)
Copy the game module into the studio frontend:
```
cp -r my-game-frontend/src/games/my-game sgs_frontend/src/games/
```

Update `sgs_frontend/src/components/GamesCatalog.tsx`:
1. Import your component.
2. Add a route condition in the render switch.
3. Add a game card in the grid.

Use the existing `number-guess` or `twenty-one` entries as templates.

### Best Practices
- Always call `player.require_auth()` for player actions.
- Validate all inputs before processing.
- Use temporary storage with proper TTL for game sessions.
- Keep contract logic simple and focused.
- Write comprehensive tests for all game flows.

## Import an Existing Game

### Step 1: Add Contract Files
```bash
cp -r /path/to/game-contract contracts/imported-game
```

### Step 2: Add to Cargo Workspace
```toml
[workspace]
members = [
  "contracts/mock-game-hub",
  "contracts/twenty-one",
  "contracts/number-guess",
  "contracts/imported-game", # Add this
]
```

### Step 3: Build, Deploy, Generate Bindings
```bash
bun run setup
```

Example: `imported-game` generates `bindings/imported_game/` and writes
`VITE_IMPORTED_GAME_CONTRACT_ID` to the root `.env`.

### Step 4: Add Frontend Component + Service
```bash
cp -r /path/to/game/<game-name>-frontend/src/games/imported-game sgs_frontend/src/games/
```

Make sure your service accepts a `contractId` (see the pattern above).

### Step 5: Register in the Catalog
Update `sgs_frontend/src/components/GamesCatalog.tsx` (import, routing, and card).

### Step 6: Deploy and Test
```bash
bun run setup
# or run steps individually:
bun run build
bun run deploy
bun run bindings
cd sgs_frontend && bun run dev
```

## Publish a Game (Self-hosted)

Game Hub does not host third-party games. To publish your game in production, you will:
1) Push your code to your own GitHub repo
2) Deploy your contract to mainnet
3) Host a standalone frontend (Vercel, Surge, Cloudflare Pages, etc.)

### Step 1: Deploy Contract to Mainnet
```bash
# Build optimized WASM
bun run build

# Install + deploy on mainnet
stellar contract install --wasm target/wasm32v1-none/release/my_game.wasm --source <ADMIN> --network mainnet
stellar contract deploy --wasm-hash <WASM_HASH> --source <ADMIN> --network mainnet -- \
  --admin <ADMIN_ADDRESS> --game-hub <GAME_HUB_MAINNET_CONTRACT_ID>
```

Find the current mainnet Game Hub contract ID in `CHITSHEET.md`.

### Step 2: Register Your Game (Whitelist)
Mainnet Game Hub only accepts outcomes from approved games. The Game Hub admin must call `add_game`.
```bash
# (Admin-only) Register your game
stellar contract invoke --id <GAME_HUB_MAINNET_CONTRACT_ID> --source <GAME_HUB_ADMIN> --network mainnet -- \
  add_game --game_id <YOUR_GAME_CONTRACT_ID> --developer <YOUR_DEVELOPER_ADDRESS>
```

### Step 3: Publish a Standalone Frontend
Use the built-in publish command to create a production-ready frontend that renders only your game.
```bash
# From game-studio/
bun run publish my-game

# Optional: choose a custom output directory
bun run publish my-game --out ../my-game-frontend
```

This will:
- Copy the studio frontend from `sgs_frontend/` (excluding build artifacts)
- Generate a standalone `App.tsx`
- Swap `useWallet` to a Stellar Wallets Kit v2 standalone wallet hook (real wallets)
- Add `LayoutStandalone` (no studio branding/sidebar)
- Create `public/game-studio-config.js` for runtime configuration

### Step 4: Configure Mainnet Contract (Runtime)
Open the generated `public/game-studio-config.js` and set mainnet values after you deploy your contract.
```js
window.__STELLAR_GAME_STUDIO_CONFIG__ = {
  rpcUrl: "https://soroban-mainnet.stellar.org",
  networkPassphrase: "Public Global Stellar Network ; September 2015",
  contractIds: {
    "my-game": "<YOUR_MAINNET_CONTRACT_ID>"
  },
  simulationSourceAddress: "<OPTIONAL_FUNDED_ADDRESS>"
};
```

This lets you update contract addresses without rebuilding the frontend.

Note: the standalone frontend uses Stellar Wallets Kit v2 to manage real wallet connections
(Freighter, etc.). Install a supported wallet extension before testing.

### Step 5: Work With the Standalone Frontend
```bash
cd ../my-game
bun install

# Local dev
bun run dev

# Production build
bun run build
```

### Step 6: Deploy
```bash
bun install
bun run build

# Vercel
vercel --prod

# Surge
npx surge dist

# Cloudflare Pages
wrangler pages deploy dist
```

## Troubleshooting

| Issue | Solution |
|-------|----------|
| `stellar: command not found` | `cargo install --locked stellar-cli --features opt` |
| `wasm32v1-none target not found` | `rustup target add wasm32v1-none` |
| `insufficient balance` | `stellar keys fund testnet --network testnet` |
| `Contract IDs not configured` | `bun run setup` |

## Resources

- [Soroban Docs](https://developers.stellar.org/docs/soroban)
- [Soroban SDK Reference](https://docs.rs/soroban-sdk/latest/soroban_sdk/)
- [Stellar CLI Guide](https://developers.stellar.org/docs/tools/developer-tools)
